use asr::{
    address::{PointerChain, Signature},
    async_main,
    future::next_tick,
    timer::{self, TimerState},
    watcher::Watcher,
    string::ArrayCString,
    Process,
};

use std::collections::{HashSet, HashMap};

#[async_main]
async fn main() {
    asr::set_tick_rate(60.0); // tick 60x/sec

    loop {
        // Attach to the process
        let process = Process::wait_attach("Dandara").await;

        // Match version
        let version = if process.module_by_name("UnityPlayer.dll").is_ok() {
            "steam"
        } else if process.module_by_name("mono.dll").is_ok() {
            "epic"
        } else {
            continue; // not found, try again
        };

        // Resolve base pointer chains
        let base_address = match version {
            "steam" => PointerChain::new("UnityPlayer.dll", vec![0x010A1120, 0x10, 0x7E0, 0x54, 0x7B4, 0x0]),
            "epic" => PointerChain::new("mono.dll", vec![0x001F72C4, 0x54, 0x280, 0x0, 0x8, 0xc8, 0x3c]),
            _ => continue,
        };

        let mut played_time = Watcher::<f32>::new();
        let mut current_scene = Watcher::<ArrayCString<255>>::new();
        let mut base_camp = Watcher::<ArrayCString<255>>::new();
        let mut is_transitioning = Watcher::<u8>::new();

        let mut event_set: HashSet<i32> = HashSet::new();
        let mut scene_set: HashSet<String> = HashSet::new();
        let mut start_credits_time = 0.0;

        // Your split mappings
        let story_event_splits: HashMap<i32, &str> = [
            (0x2, "StartedCredits"),
            (0x4, "FirstWeapon"),
            (0x32, "Killed Augustus"),
            (0x37, "Killed Eldar"),
        ].iter().copied().collect();

        // Timer update loop
        while process.is_open() {
            next_tick().await;

            let timer_state = timer::state();

            // Base address resolution
            let addr = base_address.resolve(&process).ok();
            if let Some(addr) = addr {
                // Update watchers
                let _ = played_time.update(process.read_addr::<f32>(addr.offset(0x4c)).ok());
                let _ = current_scene.update(process.read_addr::<ArrayCString<255>>(addr.offset(0x3c)).ok());
                let _ = base_camp.update(process.read_addr::<ArrayCString<255>>(addr.offset(0x48)).ok());
                let _ = is_transitioning.update(process.read_addr::<u8>(addr.offset(0x65)).ok());

                // Start logic
                if let (Some(scene), Some(is_trans)) = (current_scene.current(), is_transitioning.current()) {
                    if scene.to_string_lossy().contains("Intro") && *is_trans == 0 {
                        if timer_state == TimerState::NotRunning {
                            timer::start();
                        }
                    }
                }

                // Split logic
                for (&event_id, &name) in &story_event_splits {
                    let ptr = PointerChain::new("UnityPlayer.dll", vec![
                        0x0107DD14, 0xa8, 0x4, 0x8c, 0x54, 0x290, 0x10, 0x10, 0x10
                    ]); // Adjust for Epic if needed

                    if let Ok(array_ptr) = ptr.resolve(&process) {
                        if let Ok(event_ids) = process.read_array::<i32>(array_ptr, 200) {
                            for id in event_ids {
                                if !event_set.contains(&id) && story_event_splits.contains_key(&id) {
                                    timer::split();
                                    event_set.insert(id);
                                    break;
                                }
                            }
                        }
                    }
                }

                // Reset logic
                if timer_state == TimerState::Ended {
                    timer::reset();
                    event_set.clear();
                    scene_set.clear();
                }
            }
        }
    }
}
